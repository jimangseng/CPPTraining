생성자
Rule of 5 / Rule of 0 

make_unique를 사용해야 하는 이유

RAII Resource Acquisition Is Initialization

순환참조를 어떻게 재현해야할지 모르겠고, weak 포인터를 모르겠다


컨트롤 블록
- 객체 포인터
- 참조 카운터들
	- use_count : shared_ptr의 갯수
	- weak_count : weak_ptr의 갯수

컨트롤 블록은 shared_ptr끼리 공유되며
하나의 객체에 대해 복수의 shared_ptr이 같은 컨트롤 블록을 참조한다.

컨트롤 블록은 weak_count = 0일때만 파괴된다.
즉, use_count == 0 일 때 객체 (T*)은 delete
weak_count == 0 일 때, 컨트롤 블록 자체가 delete
shared_ptr이 모두 소멸되어도 weak_ptr이 존재하면 컨트롤 블록은 남는다.

use_count와 weak_count는 내부적으로 atomic한 연산을 사용하기 때문에 thread-safe하지만
객체 자체는 thread-safe하지 않기에 동기화가 필요하다.

컨트롤 블록은 deleter를 함께 저장.



순환 참조, weak_ptr, atomic, Thread-safe, Control Block

explicit - 주로 인자가 하나인 생성자에서 사용. 암시적 형변환을 막는다.

noexcept - 이동 생성자 / 이동 대입 연산자에서 사용. 없으면 복사 생성자 fallback 발생 std::move를 안써줌

std::move

declval


---

스마트 포인터 구현은 아직 무리인 것 같다.
기초 개념부터 차근차근히 공부해보자.

생성자부터?