value category를 나누는 이유?

왜 복사 생성자의 매개변수가 const T & 인가?

1. 참조로 받지 않으면 무한 재귀가 발생한다.
2. const가 아닌 참조로 받으면 왼값만 받을 수 있다.

const, 임시 객체, 참조, value category 등
임시 객체의 수명과 참조 문법

---

임시 객체는 곧 사라지는 객체다.
그렇기 때문에 참조(T&)에 넘기면 dangling 참조가 될 수 있어 위험하다.
따라서 컴파일러는 T&에 임시 객체 (r값)을 넘기는 것을 금지한다.

하지만 const T & 에 r값을 넘기면
r값의 '수명은 연장'된다.
그렇기 때문에 이 참조는 dangling 되지 않는다.
따라서 const T &에는 r값을 넘겨도 안전하다.

dangling reference -> 미정의 동작
use-after-free

---

객체의 '소유권 관리' 측면에서는 복사 생성자는 쓰면 안되는 걸까?

Resource를 직접 관리하는 클래스에서 이중 소유권은 문제가 된다. (Double-Free 등)
해결책은 복사를 막는다 (=delete)

---

-
std::string, std::vector 등, 값 복사가 필요한 상황 (duplicate, 새로운 소유권)
에서는 복사를 허용 (=default 또는 커스텀 구현)

-
복사 가능하나 비용이 큰 경우에는?
이동만 허용

-
복사할 이유가 명확한 객체에서만 복사 생성자를 구현, 그 외에는 복사를 금지하거나 이동만 허용.
"복사는 의도적일 때만 허용할 것" -> 모던 C++ 철학

-
특수 생성자에 대한 법칙
Rule of Zero - 리소스를 소유하지 않은 경우에는 아무것도 구현하지 말라
Rule of Five - 리소스를 직접 관리하는 경우, 복사 / 이동 / 소멸 모두 책임져야 한다